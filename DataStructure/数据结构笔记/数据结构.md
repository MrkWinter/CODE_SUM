### 1稀疏数组

1. 二维数组中大部分为0  (相同无意义的值) 
2. 用行列值存储非 0 的值 用有三列的不定行的二维数组
3. 第一行存储二维数组的 行 列数和 特殊值数
4. 有行数 - 1  为特殊值个数 列总是有三列分别是 row col value
5. 存储时省空间 (内存 和 储存)

* 基本操作

> 1. 稀疏数组的压缩
> 2. 稀疏数组的文件存储
> 3. 稀疏数组的恢复

* 详细介绍：
  1. 一个矩形数组中较多无意义的数字 这时可以选择只记录有意义的数字 (如大部分数字是0 为默认值等)
  2. 创建一个二维数组 该数组有三列 不定行 第一行记录原矩阵的长和宽 以及需要记录的数据数(恢复时使用)
  3. 从第二行开始 每一行记录矩阵中有效数据的行列与值 直到把所有有效数据记录完成
  4. 通过将较小的二维数组保存可以节省存储空间 
  5. 需要原数据时根据压缩矩阵的方法读取恢复即可

### 2队列

1. 可以用数组模拟队列
2. rear front 分别指向队列尾部和头部
3. 循环队列用的比较多

* 基本操作

  > 1. 用数组模拟队列

* 详细介绍：
  1. 队列先进先出
  2. 循环队列得到元素个数的方法为(rear+size-front)%size

### 3链表

1. 链式存储结构
2. next pre 指向下一个结点和前一个结点

* 基本操作

  > 1. 链表的逆序打印
  > 2. 链表的反转 (头插法)
  > 3. 返回第n个结点
  > 4. 将两个链表合成一个链表

* 详细介绍

  1. 链表删除和增加结点较高效
  2. 查询结点较慢
  3. 有循环链表和双向链表

### 4栈

1. 可以用数组模拟栈
2. top 指针
3. 用来递归

* 基本操作

  > 1. 用数组模拟栈

* 详细介绍

  1. 栈先进后出
  2. 函数的调用是在栈区中 递归本质上使用的是栈的数据结构

### 5哈希

1. hashtable 模拟
1. 数组加链表

* 基本操作 

  > 1. 根据哈希表的大小设置散列函数 依次可以找到对应的数组位置
  > 2. 建立链表 通过链表结点建立链表数组

* 详细介绍

  1. hash结构实际上就是数组+ 链表的结构
  2. java HashMap 集合利用的就是典型的哈希结构
  3. 哈希结构的关键是设置一个散列的哈希表

### 6二叉树(一对对多关系)

1. 二叉树前中后序遍历
1. 二叉树前中后序查找
1. 二叉树删除结点(简单删除) 
1. (顺序存储二叉树)(**特殊二叉树结构**)的前中后序遍历
1. (前中后序线索二叉树)(**特殊二叉树结构**)的构建 (线索化)
1. 哈夫曼树(最优二叉树)(**特殊二叉树结构**)的构建 
1. 二叉排序(搜索)树(**特殊二叉树结构**)BST
1. 平衡二叉树(**特殊二叉树结构**)AVL  是在二叉排序树上的升级 也称为平衡二叉搜索树  (红黑树？？？)

### 多叉树(一对多关系)

1. 2-3树 234树(都是b树 b指Balanced平衡树)

   ![image-20230804191612506](img\image-20230804191612506.png)

   

   ![image-20230805093413015](img\image-20230805093413015.png)

2. b树 (b-树 b-tree b树 b树是平衡多叉树 树的阶>=3的平衡搜索树  b树 平衡多叉搜索树)

   ![image-20230805094149333](D:\VS项目\数据结构入门\笔记\img\image-20230805094149333.png)

3. b+树

   ![image-20230805094839082](img\image-20230805094839082.png)

4. b*树

   ![image-20230805095741383](img\image-20230805095741383.png)

### 7图 (多对多关系)

1. 邻接矩阵 邻接表 (图的表示方式)
2. 图的深度优先遍历dfs (利用栈)
3. 图的广度优先遍历bfs (利用队列)

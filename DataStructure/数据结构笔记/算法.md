### 约瑟夫环

1. 循环链表解决该问题
2. 循环队列解决该问题

### 计数器模拟

1. 前缀表达式 (波兰表达式 用的较少)
2. 中缀表达式  (较为直观 人们接受的)
3. 后缀表达式 (逆波兰表达式 计算机运算方便的)

* 中缀表达式运算规则

  1. 首先判断是符号还是数字

     是符号：

     1. 如果符号栈为空 直接加入
     2. 如果符号为 ( 直接加入
     3. 如果符号为 )  不断取出符号栈符号 不断取出数字栈数字 运算后加入数字栈 直到 取出 (
     4. 如果为其他(+-*/)  取符号栈栈顶符号 如果比当前符号优先级高 取出该符号 取出两个数字 进行运算后加入数字栈 直到栈顶符号优先级不大于当前符号 将当前符号加入符号栈

     是数字

     1. 如果是字符串类型 需要考虑多位数的情况 进行数字字符拼接 直到下一位为最后一位 或者下一位为符号时开始下一步
     2. 将数字加入数字栈

  2. 将符号栈和数字栈依次取出进行运算 直到数组栈只剩一个数 该数为运算结果
  
* 前缀表达式运算规则

  1. 从右至左扫描表达式 数字压入数字栈 符号压入符号栈
  2. 依次从数字栈中取出两个数字从符号栈中取出一个符号进行运算
  3. 运算后将结果压入数字栈
  4. 重复2、3操作 直到符号栈为空 数字栈只剩一个数
  5. 该数就是波兰表达式计算结果

* 后缀表达式运算规则(计算机运算最简单)

  1. 从左至右扫描表达式
  2. 遇到数字压入数字栈 
  3. 遇到符号就从数字栈中弹出两个数字进行运算 再将结果压入数字栈中
  4. 扫描完表达式后数字栈中仅剩的一个数就是计算结果

### 中缀转后缀

1. 特定的算法
2. 根据栈实现中缀转后缀
3. 后缀计算机计算较简单

* 中缀转后缀运算规则

  1. 首先判断是数字还是符号

     是符号：

     1. 如果是 )  不断从符号栈中取出符号压入数字栈中 直到取出 (

     2. 不是 )   ---  是 + - * / 或者 （ 有以下操作

        如果符号栈为空   或者如果符号 为 (  或者符号栈栈顶的符号优先级小于当前符号 直接入符号栈

        否则 --- 符号栈栈顶的符号优先级大于当前符号  就将符号栈中符号依次取出 放入数字栈 直到符号栈栈顶元素优先级小于等于 当前符号优先级 或者符号栈取空

     是数字

     1. 考虑多位数问题 如果是数字直接压入数字栈

  2. 将符号栈中元素依次取出压入数字栈

  3. 将数字栈中元素依次取出即为逆波兰表达式

### 迷宫问题

1. 递归问题的经典问题 
2. 走一步看一步

* 方法 就是从此步观测四方是否可走 可以走的话标记 走到死路回溯重置 直到找到出口

### 八皇后问题

1. 递归回溯算法的经典案例
2. 同上思想近似

### 排序算法 (加粗为较难算法)

* 内部排序 全部加载到内存中的排序
  * 插入排序
    1. 直接插入排序
    2. **希尔排序 (缩小增量排序) **
  * 选择排序
    1. 简单选择排序
    2. **堆排序 (大顶堆和小顶堆结构)**
  * 交换排序
    1. 冒泡排序
    2. 快速排序
  * **归并排序**
  * **基数排序** (桶排序)
  
  ![image-20230801132118345](img\image-20230801132118345.png)
* 外部排序  无法全部加载到内存中 需要借助外部存储的排序

### 查找算法 (加粗为较难算法)

* 顺序查找(线性查找)
* 二分查找(折半查找)
* 插值查找(二分查找改进)
* **斐波那契查找(黄金分割查找)**

### 哈夫曼编码 (哈夫曼树的使用)

* 字符串中字符通过出现频率构建哈夫曼树
* 哈夫曼树得到字母的哈夫曼编码
* 字符串通过哈夫曼编码转二进制字符串
* 二进制字符串(补码)转换成byte数组
* byte数组转换成二进制字符串(补码)
* 二进制字符串通过哈夫曼编码转字符串



——————————————————————————



* 通过字节数组(数据内容)构建哈夫曼树
* 哈夫曼树得到字节数组(数据内容)的哈夫曼编码
* ----------------以下为对数据的压缩
* 字节数组(数据内容)通过哈夫曼编码转二进制字符串
* 二进制字符串(补码)转换成byte数组(压缩完成)
* ----------------以下为对数据的解压
* byte数组(压缩数据)转换成二进制字符串(补码)
* 二进制字符串通过哈夫曼编码转字节数组(数据内容)



### 十种经典算法

* 二分查找算法(非递归)

* 分治算法

  ![image-20230805161039331](D:/VS项目/数据结构入门/笔记/img/image-20230805161039331.png)

  ![image-20230805160614215](D:/VS项目/数据结构入门/笔记/img/image-20230805160614215.png)

* 动态规划算法

  1. 大问题分为互相独立的小问题 下一步操作需要上一步操作的结果
  2. 背包问题(01背包问题 完全背包问题)
  3. 关键为求状态转移方程

* **KMP算法**

  1. 字符串模式匹配

     通过部分匹配表循环找到适当位置

  2. 部分匹配表

     找最长公共前后缀

* 贪心算法

  1. 电台覆盖问题

     每次寻找最有利的选择 不断重复 找到较优解

* 求最小生成树算法 (修路问题 总权值最小)

  1. 普利姆算法
  
     通过点集不断找较小的边  避免联通 算法实现 三层for循环
  
  2. 克鲁斯卡尔算法
  
     通过边集不断找较小的边 避免联通  算法实现 动态联通判断数组 
  
* 最短路径算法 (到某一点的权值最小)

  1. 迪杰斯特拉算法

     从一个结点开始记录到相邻结点的最短路径 下次从最小的路径结点下继续寻找如果有更小的则更新 直到把所有结点遍历 迪杰斯特拉算法是求某一个顶点到其他顶点的最短路径

  2. 弗洛伊德算法

     所有顶点到所有顶点的最短路径 算法时间复杂度较高
  
* 马踏棋盘算法

  1. 递归+回溯


#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//4.1串的定义
//串名 串值 串长 空串
//子串:一个串中任意连续的字符称为该字符串的字串
//真子串:是不包含自身的所有子串
//主串：包含子串相应的称为主串
//字符位置：字符在序列中的序号为该字符在串中的位置
//空格串：由一个或多个空格组成的串 与空串不同
//字串位置：子串第一个字符在主串中的位置
//串相等：当且晋档两个串的长度相等并且各个对应的位置上的字符都相同 这两个串相等
//所有的空串都相等

//4.2 案例引入
//病毒dna序列检测

//4.3串的类型定义、存储结构和运算

//4.3.1串的抽象数据类型
// ADT String
//{
//	D = {a1, | a1 < -characterset i = 1,2,3,4...n;
//
//    R = { <ai - 1,ai> | ai - 1,ai < -D ,i = 1,2,3,4..n };
//
//     基本操作：求串长 串比较 串赋值 串连接等
//
//}
//4.3.2串的定义和分类
//串分为顺序串和链串
//串的数组中第一个元素不用
//#define MAXLEN 255
//串的顺序储存结构
//typedef struct {
//	char ch[MAXLEN + 1];//储存串的一维数组
//	int length;//串当前长度
//}SString;

//串的链式存储结构-块链结构
//优点 操作方便 缺点 存储密度低 因为储存密度低所以要增加结点中所放元素的个数

//#define CHUNKSIZE 80 
//typedef struct chunk {
//	char ch[CHUNKSIZE];
//	struct chunk* next;
//}Chunk;//定义结点
//typedef struct {
//	Chunk* head;
//	Chunk* tail;
//	int curlen;//当前长度
//}LString;

//4.3.3串的模式匹配算法

//算法分类
//bf与kmp算法
//bf算法

//typedef struct {
//	char ch[MAXLEN + 1];//储存串的一维数组
//	int length;//串当前长度
//}SString;
//char* Index_bf(SString* s1, SString* s2)
//{
//	int i, j;
//	for (i = 1, j = 1; i <= s1->length && j <= s2->length;)//
//	{
//		if (s1->ch[i] == s2->ch[j])//相等向后走
//		{
//			i++; j++;
//		}
//		else//不相等回溯
//		{
//			i = i - j + 2;
//			j = 1;
//		}
//	}
//	if (j > s2->length)//子串走出长度大于字符串长度 说明找到相等的子串
//		return &(s1->ch[i - j + 1]);
//	else
//		return NULL;
//}
//int main()
//{
//	SString s1 = {" abcdef",6 };
//	SString s2 = {" bcd",3 };
//	printf("%s",Index_bf(&s1, &s2));
//
//	return 0;
//}

//kmp算法

//寻找最长公共前后缀
//typedef struct
//{
//	char ch[MAXLEN + 1];
//	int length;
//}SString;
//int next(int j, SString* s2)
//{
//	if (j <= 2)//无前后缀字串
//		return 1;
//	int m, n,max = 0;
//	for (m = 1, n = j - 1; m < j - 1; m++, n--)
//	{
//		int i = 1;
//		int k = n;
//		while (i <= m)
//		{
//			if (s2->ch[i] != s2->ch[k])
//				break;
//			i++; k++;
//		}
//		if (i > m)
//			max = max > m ? max : m;
//	}
//	return max + 1;
//}
//char* Index_kmp(SString* s1, SString* s2)
//{
//	int i, j;
//	for (i = 1, j = 1; i <= s1->length && j <= s2->length;)//
//	{
//		if (s1->ch[i] == s2->ch[j])//相等向后走
//		{
//			i++; j++;
//		}
//		else//不相等next函数分情况
//		{
//			if (j == 1) //第一个模式串字符不同 和下一个比
//			{
//				j = next(j,s2);
//				i++;
//			}
//			else
//			{
//				j = next(j,s2); //第2~n个字符串比 分情况
//			}
//		}
//	}
//	if (j > s2->length)//子串走出长度大于字符串长度 说明找到相等的子串
//		return &(s1->ch[i - j + 1]);
//	else
//		return NULL;
//
//}
//int main()
//{
//	SString s1 = {" abcdef",6 };
//	SString s2 = {" bcd",3 };
//	printf("%s",Index_kmp(&s1, &s2));
//	return 0;
//}

//4.4数组
//
//二维数组的逻辑结构 
//1线性结构  二维数组在内存中也是定长的线性表
//
//2非线性结构 二维数组中的元素既在行中 又在列中 可以说不止和前后元素有关系
//
//结论 线性表结构是数组的一个特例  数组结构是线性表结构的扩展
//
//数组的特点 结构固定 定义后维度和维界不再改变

//4.4.1 数组的抽象数据类型定义
//
//
//4.4.2数组的顺序存储 
//
//二维数组的存储的两种方式 
//
//按照以行序为主序存储 以列序为主序存储
//
//以行序为主序进行存储 a[i][j] 前有i*n+j个元素

//4.4.3 特殊矩阵的压缩存储
//
//矩阵 一个又m*n 个元素排成的m行n列的表
//
//矩阵的存储 描述为一个二维数组
//
//若多个数据元素的值都相等 则分配一个元素的存储空间 且零元素不占空间
//
//矩阵的压缩存储是为了减小空间的使用 
//
//什么样的矩阵能压缩 对称矩阵 对角矩阵 三角矩阵 稀疏矩阵等(矩阵中非0元素的个数较小 一般小于%5)
//
//1.对称矩阵
//
//储存方法 值存储下或上三角的数据元素（包括对角线） 共占用n*（n+1）/2
//
//将n*(n+1)/2 个元素储存在一维数组中  矩阵中的a[i][j] 个元素储存在数组的n*（n-1）/2+j个位置

//2.三角矩阵
//
//特点 对角线以上或以下都为常数c 不包括对角线
//
//将n*（n+1）/2+1个元素存储在一维数组中
//
//同对称矩阵可推出 矩阵中a[i][j] 在一维数组中的位置
//
//3.对角矩阵
//
//特点 非0元素集中在以主对角线为中心的带状区域中 区域外的值全为0  
//
//有三对角矩阵 五对角矩阵 七对角矩阵等
//
//将对角矩阵中元素存储在二维矩阵中 主对角线上的元素个数为二维数组的列数 对角线的个数为二维数组的行数
//
//并且对称存储  0元素不管
//
//4.稀疏矩阵
//
//特点 在m*n 的矩阵中超过%95的元素都为0 
//
//  *用三元组（二维数组？）的方式进行表示 （1,2,13）  解释 ：第一行 第二行 元素为13
//
//用三元组 （4，5 ，10）表示4行5列非0元素个数为10 代表稀疏矩阵的信息 放在首位  矩阵维数为2
//
//三元组顺序表又称有序的双下标法
//
//三元组法的优点 非零元在表中按行序有序存储 因此便于进行依行顺序处理的矩阵运算
//
//缺点 不能随机存取 按行号存取某一行中的非0元素 则需要从头开始进行查找
// 
//  *十字链表表示稀疏矩阵 数据域存储三元组 指针域中有两个指针 一个指向同行的右边的下一个结点 
//
//一个指向同列的下面的下一个结点 同时定义头指针 根据多少行和列定义多少的头指针 每一行和每一列都定义一个头指针
//
//
//优点 它能够灵活的插入因运算产生的新的非0元素
//
//删除因运算产生的新的0元素 实现矩阵的各种运算
//
//有效解决了三元组法的局限性
//typedef struct shizi
//{
//	int arr[3];//定义数据三元组 表示稀疏矩阵中的非0 元素
//	struct shizi* down; //指向同一列中下一个元素
//	struct shizi* righit //指向同一行中下一个元素
//};
//
//4.5广义表
//
//定义： 由 LS = (a1,a2,a3,a4...,an) 由n个元素组成的表 
//表中元素可以是一个原子(非广义表)，或者是一个广义表
//LS 为表名 n为表的长度 一般用大写字母表示广义表 小写字母表示原子
//广义表中没有元素称为空表
//
//表头：若非空 第一个元素是表头 表头可以是原子 也可以是子表(广义表中的广义表)
//表尾：剩下的元素组成的子表为表尾 
//
//广义表有递归（嵌套）广义表和共享广义表
//
//
//广义表的性质
//1元素数据有相对次序 有前驱后后继
//2广义表的长度定义为广义表最外层包含元素个数
//3广义表的深度为广义表展开后所含括号的的重数
//4广义表可以被共享
//5广义表可以递归 递归的广义表深度为无穷 长度为有限值
//6广义表可以无限套娃
//
//广义表和线性表的区别
//
//广义表是线性表的推广 线性表是广义表的特例
//广义表可以兼容线性表 数组 树 图等多种数据结构 
//如二维数组的每行或每列作为子表处理时 二维数组就是一个广义表

//广义表的基本运算
//
//求表头 求表尾
//
//广义表通常用链式存储

//4.6案例分析和实现
//病毒感染检测
//
//kmp算法 + 字符串拷贝拼接实现